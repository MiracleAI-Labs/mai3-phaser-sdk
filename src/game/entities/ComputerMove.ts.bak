import Movement from "./Movement";
import { ComputerMoveConfig } from "./interface"
import { OrientEnum } from "./enum"
import HealthBar from "./HealthBar";
// import { PlayScene } from "@/scenes/PlayScene";
import Computer from "./Computer";
import { Grid, AStarFinder } from 'pathfinding';


const ComputerMove = {
   originX: 0,
   originY: 0,
   finder: AStarFinder,
   grid: Grid,
   path: null as number[][] | null,
   targerobj: null as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody | null,
   ss: 1,
   NewMove(scene: any, gameobj: Computer, healthbar?: HealthBar, config: ComputerMoveConfig) {
      this.originX = gameobj.computerSprites.x
      this.originY = gameobj.computerSprites.y
      this.MoveAuto(scene, gameobj, healthbar, config)
      // if (gameobj.moveType === 1) { //自动移动
      //    this.MoveAuto(scene, gameobj.computerSprites, healthbar, config)
      // } else { //受攻击移动
      //    this.MoveDest(scene, gameobj.computerSprites, healthbar)
      // }
   },
   MoveAuto(scene: any, gameobj: Computer, healthbar?: HealthBar, config: ComputerMoveConfig) {
      let rotation = 1
      const distance = config.distance! > 0 ? (config.distance! < 20 ? 20 : config.distance) : ((config.distance! > -20 && config.distance! < 0) ? -20 : config.distance)
      // let originX = gameobj.x
      // let originY = gameobj.y
      let destX = 0
      let destY = 0
      if (config.orient === OrientEnum.Horizontal) {
         destX = gameobj.computerSprites.x + Number(distance)
         destY = gameobj.computerSprites.y
      } else {
         destX = gameobj.computerSprites.x
         destY = gameobj.computerSprites.y + Number(distance)
      }
      scene.physics.world.on('worldstep', () => {
         if (gameobj.moveType === 1) {
            if (rotation === 1 && Number(distance) !== 0) {
               scene.physics.moveTo(gameobj.computerSprites, destX, destY, 100)
               let betweenDistance = Phaser.Math.Distance.Between(gameobj.computerSprites.x, gameobj.computerSprites.y, destX, destY);
               if (betweenDistance < 1) { // 当距离目的地小于10像素时停止
                  gameobj.computerSprites.body.setVelocity(0);
                  Movement.stop(scene, gameobj.computerSprites)
                  rotation = 2
               }
            } else if (rotation === 2 && Number(distance) !== 0) {
               scene.physics.moveTo(gameobj.computerSprites, this.originX, this.originY, 100)
               let betweenDistance = Phaser.Math.Distance.Between(gameobj.computerSprites.x, gameobj.computerSprites.y, this.originX, this.originY);
               if (betweenDistance < 1) { // 当距离目的地小于10像素时停止
                  gameobj.computerSprites.body.setVelocity(0);
                  Movement.stop(scene, gameobj.computerSprites)
                  rotation = 1
               }
            }
            ComputerMove.MoveAnimation(scene, gameobj.computerSprites, config.orient!, distance!, rotation)
         } else {

            if (this.ss === 1) {
               this.targerobj = gameobj.computerSprites
               //this.MoveDest(scene, gameobj.computerSprites)

               const gridWidth = 21; // 网格宽度
               const gridHeight = 36; // 网格高度

               // 创建网格
               this.grid = new Grid(gridWidth, gridHeight);

               this.finder = new AStarFinder();
               this.findPath(scene);
               this.ss = 2
            }

         }
         healthbar?.SetPosition(gameobj.computerSprites.x, gameobj.computerSprites.y - 20)
      })
   },

   MoveDest(scene: any, gameobj: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody) {
      const graphics = scene.add.graphics();
      //const follower = { t: 0, vec: new Phaser.Math.Vector2() };
      const path = new Phaser.Curves.Path(100, 100);
      path.lineTo(100, 200);
      path.lineTo(200, 200);
      graphics.lineStyle(2, 0xffffff, 1);
      path.draw(graphics)

      // const destX = scene.player?.playerSprites.x
      // const destY = scene.player?.playerSprites.y
      // const speed = 100
      // let dx = 0;
      // let dy = 0;
      // const deltaX = Number(destX) - gameobj.x;
      // const deltay = Number(destY) - gameobj.y;
      // // 向右移动
      // if (Number(deltaX) > 0) {
      //    dx = speed;
      // }
      // // 向左移动
      // else if (Number(deltaX) < 0) {
      //    dx = -speed;
      // }
      // // 向下移动
      // if (Number(deltay) > 0) {
      //    dy = speed;
      // }
      // // 向上移动
      // else if (Number(deltay) < 0) {
      //    dy = -speed;
      // }
      // console.log(dy)
      // gameobj.setVelocity(dx, 0);
      // // 当游戏对象接近目标位置时停止移动
      // if (Math.abs(gameobj.x - Number(destX)) < 1 && Math.abs(gameobj.y - Number(destY)) < 1) {
      //    gameobj.setVelocity(0, 0);
      // }
   },
   findPath(scene: any): void {
      console.log(" this.targerobj!.x/32-->", this.targerobj!.x / 32)

      const start = { x: Math.round(this.targerobj!.x / 32), y: Math.round(this.targerobj!.y / 32) }; // 起点
      //const start = { x:  this.targerobj!.x/32, y:this.targerobj!.y/32 }
      const end = { x: 10, y: 20 }; // 终点
      // 查找路径
      this.path = this.finder.findPath(start.x, start.y, end.x, end.y, this.grid);
      console.log("this.path:", this.path)

      // 渲染路径
      const pathGraphics = scene.add.graphics({ lineStyle: { width: 2, color: 0x00ff00 } });
      pathGraphics.lineStyle(2, 0x00ff00, 1);

      this.path.forEach((point, index) => {
         if (index === 0) {
            pathGraphics.moveTo(point[0] * 32, point[1] * 32); // 转换坐标
         } else {
            pathGraphics.lineTo(point[0] * 32, point[1] * 32);
         }
      });
      pathGraphics.strokePath();

      // 移动角色
      this.moveAlongPath(scene);
   },
   moveAlongPath(scene: any) {
      console.log(scene)
      // 将路径转化为 Phaser tween 动画

      // const tweenConfig: Phaser.Types.Tweens.TweenBuilderConfig = {
      const tweenConfig = {
         targets: this.targerobj!,
         props: { custom: { from: 0, to: 1 } }, // 使用一个虚拟属性
         ease: 'Power2',
         duration: 4000,
         onUpdate: (tween: Phaser.Tweens.Tween) => {
            // 根据 tween 的进度更新角色位置
            const progress = tween.progress;
            const currentIndex = Math.floor(progress * (this.path!.length - 1));
            const nextIndex = Math.min(currentIndex + 1, this.path!.length - 1);

            const currentPoint = this.path![currentIndex];
            const nextPoint = this.path![nextIndex];

            const currentX = currentPoint[0] * 32;
            const currentY = currentPoint[1] * 32;
            const nextX = nextPoint[0] * 32;
            const nextY = nextPoint[1] * 32;

            // 插值计算
            const lerp = (t: number, start: number, end: number) => start + t * (end - start);
            this.targerobj!.setPosition(
               lerp(progress, currentX, nextX),
               lerp(progress, currentY, nextY)
            );
         }
      };
      // 创建 tween 动画
      scene.tweens.add(tweenConfig);
   },
   MoveAnimation(scene: Phaser.Scene, gameobj: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody, origen: OrientEnum, distance: number, rotation: Number) {
      if (origen === OrientEnum.Horizontal) {
         if ((distance > 0 && rotation === 1) || (distance < 0 && rotation === 2)) {
            Movement.right(scene, gameobj)
         } else if ((distance < 0 && rotation === 1) || (distance > 0 && rotation === 2)) {
            Movement.left(scene, gameobj)
         }
      } else {
         if ((distance > 0 && rotation === 1) || (distance < 0 && rotation === 2)) {
            Movement.down(scene, gameobj)
         } else if ((distance > 0 && rotation === 2) || (distance < 0 && rotation === 1)) {
            Movement.up(scene, gameobj)
         }
      }
   }
}

export default ComputerMove
