import { Container } from './Container';
import Utils from '../utils';
import { BaseScene } from "../game";
import { TextButton } from './TextButton';
import { TextBox } from './TextBox';
import { ImageButton } from './ImageButton';
import { RoundedButton } from './RoundedButton';
import { Checkbox } from './Checkbox';
import { CheckboxGroup } from './CheckboxGroup';
import { Label } from './Label';
import { ProgressBar } from './ProgressBar';
import { Slider } from './Slider';
import { VolumeSlider } from './VolumeSlider';
import { GridConfig } from '../types';
import { Image } from './Image';

interface GridLayoutItem {
    row: number;
    column: number;
    x: number;
    y: number;
    width: number;
    height: number;
    child?: Container;
}

export class Grid extends Container {
    private _content?: Container;
    private _gridLines?: Phaser.GameObjects.Graphics;
    private _draggingChild?: Container;
    private _originalPosition?: { x: number; y: number };
    private _originalIndex?: number;

    private _cellWidth: number = 0;
    private _cellHeight: number = 0;

    config?: GridConfig;
    image?: Phaser.GameObjects.Image;
    gridItemsMap: Map<string, Container | number> = new Map<string, Container | number>();

    constructor(scene: BaseScene, config: GridConfig) {
        super(scene, config);
        this.scene = scene;
        this.Type = 'Grid';
        this.draw(config);
    }

    draw(config: GridConfig) {
        this.config = config;
        const width = config.width ?? 200;
        const height = config.height ?? 300;
        const padding = config.padding ?? 0;

        const layoutBg = this.createBg(0, 0, width, height, config);
        this.addChildAt(layoutBg!, 0);

        this._content = new Container(this.scene);
        this._content.setPosition(padding, padding);
        this.addChildAt(this._content, 1);

        this.scene.input.enableDebug(this._content);
        this.RefreshBounds();
        this.setGridPlace();
    }

    reDraw(config: GridConfig) {
        this.clear();
        this.draw(config);
    }

    clear() {
        this._content?.removeAll(false);
        this.getAll().forEach((obj) => {
            obj.destroy();
        });
        if (this._gridLines) {
            this._gridLines.destroy();
            this._gridLines = undefined;
        }
    }

    setGridPlace() {
        const { width = 200, height = 200, columns = 1, rows = 1, padding = 0, columnGap = 0, rowGap = 0 } = this.config!;
        const contentWidth = width - padding * 2;
        const contentHeight = height - padding * 2;
        this._cellWidth = (contentWidth - (columns - 1) * columnGap) / columns;
        this._cellHeight = (contentHeight - (rows - 1) * rowGap) / rows;

        for (let i = 0; i < columns; i++) {
            for (let j = 0; j < rows; j++) {
                const x = i * (this._cellWidth + columnGap);
                const y = j * (this._cellHeight + rowGap);
                this.gridItemsMap.set(`${x}-${y}`, 0);
            }
        }
    }

    public addRow(childConfigs: any[]) {
        const { width = 200, height = 200, columns = 1, rows = 1,  padding = 0, columnGap = 0, rowGap = 0 } = this.config!;
        const lastGameObject = this._content?.getAll().slice(-1)[0] as Container;

        let nextX = 0; 
        let nextY = lastGameObject ? lastGameObject.y + this._cellHeight + rowGap : 0;  
        childConfigs.forEach((childConfig) => {        
            const mergedConfig = {
                ...childConfig,
                x: nextX,
                y: nextY,
                width: this._cellWidth,
                height: this._cellHeight
            };

            const child = this.createChildFromConfig(mergedConfig);
            this.setupDraggable(child);
            this._content!.addChild(child);

            this.gridItemsMap.set(`${nextX}-${nextY}`, child);

            nextX += this._cellWidth + columnGap;
        });
    }

    public addCellItems(childConfigs: any[]) {
        this.getEmptyCells().forEach((emptyCell) => {
            if (childConfigs.length === 0) return;
            
            const childConfig = childConfigs.shift();
            const mergedConfig = {
                ...childConfig,
                x: emptyCell.x,
                y: emptyCell.y,
                width: this._cellWidth,
                height: this._cellHeight
            };

            const child = this.createChildFromConfig(mergedConfig);
            this.setupDraggable(child);
            this._content!.addChild(child);
        });
    }

    public getEmptyCells() {
        const positions: { x: number; y: number; }[] = [];
        this.gridItemsMap.forEach((value, key) => {
            if (value === 0) {
                const xy = key.split('-');
                positions.push({ x: parseInt(xy[0]), y: parseInt(xy[1]) });
            }
        });

        return positions;
    }

    private createChildFromConfig(config: any): Container {
        let child: Container;
        switch (config.type) {
            case 'Image':
                child = new Image(this.scene, config);
                break;
            case 'TextButton':
                child = new TextButton(this.scene, config);
                break;
            case 'TextBox':
                child = new TextBox(this.scene, config);
                break;
            case 'ImageButton':
                child = new ImageButton(this.scene, config);
                break;
            case 'RoundedButton':
                child = new RoundedButton(this.scene, config);
                break;
            case 'Checkbox':
                child = new Checkbox(this.scene, config);
                break;
            case 'CheckboxGroup':
                child = new CheckboxGroup(this.scene, config);
                break;
            case 'Label':
                child = new Label(this.scene, config);
                break;
            case 'ProgressBar':
                child = new ProgressBar(this.scene, config);
                break;
            case 'Slider':
                child = new Slider(this.scene, config);
                break;
            case 'VolumeSlider':
                child = new VolumeSlider(this.scene, config);
                break;
            default:
                child = new TextButton(this.scene, config);
        }
        return child;
    }

    private setupDraggable(child: Container) {
        if (!this.config?.draggable) return;

        child.setInteractive();
        this.scene.input.setDraggable(child);

        child.on('dragstart', (_: Phaser.Input.Pointer) => {
            this._draggingChild = child;
            this._originalPosition = { x: child.x, y: child.y };
            this._originalIndex = this._content!.getIndex(child);
            this._content!.bringToTop(child);
        });

        child.on('drag', (_: Phaser.Input.Pointer, dragX: number, dragY: number) => {
            child.x = dragX;
            child.y = dragY;
        });

        child.on('dragend', (pointer: Phaser.Input.Pointer) => {
            const localPoint = this._content!.getLocalPoint(pointer.x, pointer.y);
            const targetChild = this.getChildAtPosition(localPoint.x, localPoint.y);
            if (targetChild && targetChild !== child) {
                const targetIndex = this._content!.getIndex(targetChild);
                child.setPosition(targetChild.x, targetChild.y);
                targetChild.setPosition(this._originalPosition!.x, this._originalPosition!.y);

                this._content!.moveTo(child, targetIndex);
                this._content!.moveTo(targetChild, this._originalIndex!);

                this.gridItemsMap.set(`${child.x}-${child.y}`, child);
                this.gridItemsMap.set(`${targetChild.x}-${targetChild.y}`, targetChild);
            } else {
                this.setChildPosition(child, this._originalPosition!.x, this._originalPosition!.y);
                this._content!.moveTo(child, this._originalIndex!);
            }

            this._draggingChild = undefined;
            this._originalPosition = undefined;
            this._originalIndex = undefined;
        });
    }

    private getChildAtPosition(x: number, y: number): Container | undefined {
        const children = this._content!.getAll() as Container[];
        const child = children.find(child => {
            if (child !== this._draggingChild) {
                return x >= child.x && x <= child.x + child.RealWidth && y >= child.y && y <= child.y + child.RealHeight;
            }
            return false;
        });

        return child;
    }

    private setChildPosition(child: Container, x: number, y: number) {
        child.x = x;
        child.y = y;
    }

    private createBg(
        x: number,
        y: number,
        width: number,
        height: number,
        config: GridConfig) {
        if (typeof config.background === 'string' && !config.background.startsWith('#')) {
            const bg = this.scene.make.image({ x: 0, y, key: config.background });
            bg.setDisplaySize(width, height);
            bg.setOrigin(0);
            return bg;
        }

        const backgroundColor = config.background
            ? ((typeof config.background === 'string' && config.background.startsWith('#')
                ? Utils.hexColorToNumber(config.background) : config.background as number)) : 0x000000;

        const rt = Utils.drawRoundedRectRenderTexture(this.scene, x, y,
            width, height, config.borderWidth,
            config.radius, config.borderColor, backgroundColor);

        return rt;
    }
}
